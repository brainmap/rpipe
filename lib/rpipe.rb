require 'rubygems'
require 'yaml'
require 'ftools'
require 'fileutils'

# prevent zipping in FSL programs
ENV['FSLOUTPUTTYPE'] = 'NIFTI'


class JobStep
	
	COLLISION_POLICY = :panic # options -- :panic, :destroy, :overwrite
	
	attr_accessor :subid, :rawdir, :origdir, :procdir, :spmdir, :collision_policy
	
	def initialize(workflow_spec, job_spec)
		# allow jobspec to override the workflow spec
		@subid   = job_spec['subid']   || workflow_spec['subid']
		@rawdir  = job_spec['rawdir']  || workflow_spec['rawdir']
		@origdir = job_spec['origdir'] || workflow_spec['origdir']
		@procdir = job_spec['procdir'] || workflow_spec['procdir']
		@spmdir = job_spec['spmdir'] || workflow_spec['spmdir']
		@collision_policy = (job_spec['collision'] || workflow_spec['collision'] || COLLISION_POLICY).to_sym
		
		include_job_methods(job_spec['method'])
	end
	
	def include_job_methods(method)
		if method.nil? or ['default','wadrc'].include?(method)
			# do nothing, use default preproc implementation
		else
			custom_method_file = File.join(File.dirname(__FILE__), 'custom_methods', method + '.rb')
			if File.exist? custom_method_file
			  require custom_method_file
			  send(:extend, self.class.const_get(method))
		  else
		    raise ScriptError, "Can't find custom method file #{custom_method_file}."
		  end
		end
	end
	
	# displays a message and the date/time to standard output.
	def flash(msg)
		puts
		puts "+" * 120
		printf "\t%s\n", msg
		printf "\t%s\n", Time.now
		puts "+" * 120
		puts
	end
	
	def setup_directory(path, logging_tag)
		if File.exist?(path)
			if @collision_policy == :destroy
				puts "#{logging_tag} :: Deleting directory #{path}"
				FileUtils.rm_rf(path)
				FileUtils.mkdir(path)
			elsif @collision_policy == :overwrite
				puts "#{logging_tag} :: Overwriting inside directory #{path}"
			else
				raise(IOError, "Directory already exists, exiting: #{path}")
			end
		else
			puts "#{logging_tag} :: Creating new directory #{path}"
			FileUtils.mkdir(path)
		end
	end
	
end



########################################################################################################################
# A class for performing initial reconstruction of both functional and anatomical MRI scan acquisitions.
# Uses AFNI to convert from dicoms to 3D or 4D nifti files, initial volume stripping, and slice timing correction.
# Currently, only dicom raw data is supported, and only supports the I****.dcm file naming convention.
class Reconstruction < JobStep
	require 'default_recon'
	include DefaultRecon
	
	VOLUME_SKIP = 3 # number of volumes to strip from beginning of functional scans.
	
	attr_accessor :scans, :volume_skip
	
	# Instances are initialized with a properly configured hash containing all the information needed to drive
	# reconstruction tasks.	 This hash is normally generated with a Pipe object.
	def initialize(workflow_spec, recon_spec)
		
		super(workflow_spec, recon_spec)
		
		@scans = recon_spec['scans']
		@volume_skip = recon_spec['volume_skip'] || VOLUME_SKIP
		
		method = recon_spec["method"]
		if method.nil? or ['default','wadrc'].include?(method)
			# do nothing, use default recon implementation
		else
			# custom includes would go here to provide alternate implementations
		end
		
	end

end
###############################################	 END OF CLASS	 #########################################################




########################################################################################################################
# A class for performing spatial preprocessing steps on functional MRI data in preparation for first level stats.
# Preprocessing includes setting up output directories, linking all appropriate data, customizing a preconfigured spm
# job, running the job, calculating withing scan motion derivatives, and finally checking for excessive motion.
# The spm job should normally include tasks for realignment, normalization, and smoothing. 
class Preprocessing < JobStep
	require 'default_preproc'
	include DefaultPreproc

	MOTION_THRESHOLD = 1 # maximum allowable realignment displacement in any direction

	attr_accessor :tspec, :motion_threshold

	# Initialize instances with a hash normally generated by a Pipe object.
	def initialize(workflow_spec, preproc_spec)
		
		super(workflow_spec, preproc_spec)
		
		@tspec = preproc_spec['template_spec']
		@motion_threshold = preproc_spec['motion_threshold'] || MOTION_THRESHOLD
		
		method = preproc_spec["method"]
		if method.nil? or ['default','wadrc'].include?(method)
			# do nothing, use default preproc implementation
		else
			# custom includes would go here to provide alternate implementations
		end
		
	end

end
###############################################	 END OF CLASS	 #########################################################





########################################################################################################################
# A class used to compute the first level stats for a functional MRI visit data set.
# Currently very incomplete, any ideas for other data/attributes we need here?
class Stats < JobStep
	require 'default_stats'
	include DefaultStats
	
	attr_accessor :tspec, :onsetsfile
	
	# Initialize instances with a hash normally generated by a Pipe object.
	def initialize(workflow_spec, stats_spec)
		
		super(workflow_spec, stats_spec)
		
		@tspec = stats_spec['template_spec']
		@onsetsfiles = stats_spec['onsetsfiles']
		
		method = stats_spec["method"]
		if method.nil? or ['default','wadrc'].include?(method)
			# do nothing, use default stats implementation
		else
			# custom includes would go here to provide alternate implementations
		end
		
	end
	
end
###############################################	 END OF CLASS	 #########################################################





########################################################################################################################
# An object that drives all the other pipeline classes in this module.	Once initialized, an array of instances of each
# class are available to run segments of preprocessing.
class RPipe
	
	attr_accessor :recon_jobs, :preproc_jobs, :stats_jobs, :workflow_spec
	
	# To initialize an instance create a yaml configuration file and pass the filename to the constructor
	# Yaml drivers contain a list of entries, each of which contains all the information necessary to create an instance
	# the proper object that executes the job.	Details on the formatting of the yaml drivers including examples will be
	# provided in other documentation.
	# Raises an error if the file is not found in the file system.
	def initialize(driver_file)
		@recon_jobs = []
		@preproc_jobs = []
		@stats_jobs = []
		
		raise(IOError, "Driver file not found: #{driver_file}") unless File.exist?(driver_file)
		File.open(driver_file) do |yf|
			@workflow_spec = YAML.load(yf)
		end
		
		jobs = @workflow_spec['jobs']
		
		jobs.each do |job_params|
			@recon_jobs   << Reconstruction.new(@workflow_spec, job_params) if job_params['step'] == 'reconstruct'
			@preproc_jobs << Preprocessing.new(@workflow_spec, job_params)  if job_params['step'] == 'preprocess'
			@stats_jobs   << Stats.new(@workflow_spec, job_params)          if job_params['step'] == 'stats'
		end
	end
	
end
###############################################	 END OF CLASS	 #########################################################
